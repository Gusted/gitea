// Copyright 2022 The Gitea Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package dev

import (
	"sync"

	"code.gitea.io/gitea/modules/log"
	"code.gitea.io/gitea/modules/translation/i18n/common"
	"github.com/fsnotify/fsnotify"
)

// This file implements the development LocaleStore

type locale struct {
	store    *localeStore
	langName string
	textMap  map[int]string // the map key (idx) is generated by store's textIdxMap

	filename string
}

type localeStore struct {
	// After initializing has finished, these fields are read-only.
	langNames []string
	langDescs []string

	localeMapLock sync.RWMutex
	localeMap     map[string]*locale

	textIdxMapLock sync.RWMutex
	textIdxMap     map[string]int

	defaultLang string

	watcherLock sync.Mutex
	watcher     *fsnotify.Watcher
}

// NewLocaleStore creates a production locale store
func NewLocaleStore() *localeStore {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Error("Unable to create new watcher for locale files. Locale files will not auto-reloaded. Error: %v", err)
	}

	store := &localeStore{
		localeMap:  make(map[string]*locale),
		textIdxMap: make(map[string]int),
		watcher:    watcher,
	}
	go store.Run()
	return store
}

func (ls *localeStore) Run() {
	for {
		ls.watcherLock.Lock()
		watcher := ls.watcher
		ls.watcherLock.Unlock()
		if watcher == nil {
			return
		}

		var ok bool
		select {
		case _, ok = <-watcher.Events:
		case _, ok = <-watcher.Errors:
		}
		if !ok {
			return
		}
		ls.watcherLock.Lock()
		watcher.Close()
		var err error
		ls.watcher, err = fsnotify.NewWatcher()
		ls.watcherLock.Unlock()
		ls.refreshLocales()
		if err != nil {
			log.Error("Unable to create new watcher for locale files. Locale files will not auto-reloaded. Error: %v", err)
			return
		}
	}
	// no-op
}

func (ls *localeStore) refreshLocales() error {
	ls.localeMapLock.RLock()
	newLocaleMap := map[string]*locale{}
	for name, oldLc := range ls.localeMap {
		if oldLc.filename == "" {
			newLocaleMap[name] = oldLc
		}
		lc := &locale{store: ls, langName: oldLc.langName, textMap: make(map[int]string), filename: oldLc.filename}

		if err := common.AddFromIni(lc, lc.filename); err != nil {
			ls.localeMapLock.RUnlock()
			return err
		}
		newLocaleMap[name] = lc
		ls.watcherLock.Lock()
		if ls.watcher != nil {
			_ = ls.watcher.Add(lc.filename)
		}
		ls.watcherLock.Unlock()
	}
	ls.localeMapLock.RUnlock()
	ls.localeMapLock.Lock()
	for name, lc := range ls.localeMap {
		if _, ok := newLocaleMap[name]; ok {
			continue
		}
		newLocaleMap[name] = lc
	}
	ls.localeMap = newLocaleMap
	ls.localeMapLock.Unlock()
	return nil
}

// AddLocaleByIni adds locale by ini into the store
// if source is a string, then the file is loaded
// if source is a []byte, then the content is used
func (ls *localeStore) AddLocaleByIni(langName, langDesc string, source interface{}) error {
	ls.localeMapLock.RLock()
	if _, ok := ls.localeMap[langName]; ok {
		ls.localeMapLock.RUnlock()
		return common.ErrLocaleAlreadyExist
	}
	ls.localeMapLock.RUnlock()

	lc := &locale{store: ls, langName: langName, textMap: make(map[int]string)}

	if filename, ok := source.(string); ok {
		lc.filename = filename
	}

	if err := common.AddFromIni(lc, source); err != nil {
		return err
	}

	ls.langNames = append(ls.langNames, langName)
	ls.langDescs = append(ls.langDescs, langDesc)

	ls.localeMapLock.Lock()
	ls.localeMap[lc.langName] = lc
	ls.localeMapLock.Unlock()

	if lc.filename != "" {
		ls.watcherLock.Lock()
		if ls.watcher != nil {
			_ = ls.watcher.Add(lc.filename)
		}
		ls.watcherLock.Unlock()
	}
	return nil
}

func (ls *localeStore) HasLang(langName string) bool {
	_, ok := ls.localeMap[langName]
	return ok
}

func (ls *localeStore) ListLangNameDesc() (names, desc []string) {
	return ls.langNames, ls.langDescs
}

// SetDefaultLang sets default language as a fallback
func (ls *localeStore) SetDefaultLang(lang string) {
	ls.localeMapLock.Lock()
	ls.defaultLang = lang
	ls.localeMapLock.Unlock()
}

// Tr translates content to target language. fall back to default language.
func (ls *localeStore) Tr(lang, trKey string, trArgs ...interface{}) string {
	l, ok := ls.localeMap[lang]
	if !ok {
		l, ok = ls.localeMap[ls.defaultLang]
	}
	if ok {
		return l.Tr(trKey, trArgs...)
	}
	return trKey
}

// Tr translates content to locale language. fall back to default language.
func (l *locale) Tr(trKey string, trArgs ...interface{}) string {
	trMsg := trKey
	l.store.textIdxMapLock.RLock()
	textIdx, ok := l.store.textIdxMap[trKey]
	l.store.textIdxMapLock.RUnlock()
	if ok {
		if msg, ok := l.textMap[textIdx]; ok {
			trMsg = msg // use current translation
		} else {
			l.store.textIdxMapLock.RLock()
			var def *locale
			defaultLang := l.store.defaultLang
			if def, ok = l.store.localeMap[l.store.defaultLang]; ok {
				// try to use default locale's translation
				if msg, ok = def.textMap[textIdx]; ok {
					trMsg = msg
				}
			}
			l.store.textIdxMapLock.RUnlock()
			if ok {
				log.Warn("missing i18n translation for %q in %s using default (%s)", trKey, l.langName, defaultLang)
			}
		}
	}
	if !ok {
		log.Error("missing i18n translation for %q in %s", trKey, l.langName)
	}

	msg, err := common.Format(trMsg, trArgs...)
	if err != nil {
		log.Error("Error whilst formating %q in %s: %v", trKey, l.langName, err)
	}
	return msg
}

// Tr translates content to locale language. fall back to default language.
func (l *locale) Add(key, value string) {
	l.store.textIdxMapLock.Lock()
	textIdx, ok := l.store.textIdxMap[key]
	if !ok {
		textIdx = len(l.store.textIdxMap)
		l.store.textIdxMap[key] = textIdx
	}
	l.store.textIdxMapLock.Unlock()
	l.textMap[textIdx] = value
}

func (ls *localeStore) Close() error {
	ls.watcherLock.Lock()
	defer ls.watcherLock.Unlock()
	if ls.watcher != nil {
		return ls.watcher.Close()
	}
	return nil
}
